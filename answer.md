1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

### RDBMS
<pre>
관계형 데이터베이스(RDBMS)는 다른 테이블들과 관계를 맺고 모여있는 집합체로 이해할 수 있다.
이러한 관계를 나타내기 위해 외래 키(foreign key)라는 것을 사용한 테이블 간 Join이 가능하다.
</pre>

### NoSQL
<pre>
Not Only SQL
RDB 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술 (테이블 간 관계를 정의하지 않는다.)
데이터 테이블은 그냥 하나의 테이블이며 따라서 일반적으로 테이블 간 Join도 불가능하다.
데이터일관성은 포기하되 비용을 고려하여 여러 대의 데이터에 분산하여 저장하는 Scale-out을 목표로 등장
</pre>

<table style="border: 2px;">
    <tr>
      <td>  </td>
      <td> RDB </td>
      <td> NoSQL </td>
    </tr>
    <tr>
      <td>데이터 저장 모델</td>
      <td>table</td>
      <td>document, key-value, graph 등</td>
    </tr>
    <tr>
      <td>개발 목적</td>
      <td>데이터 중복 감소</td>
      <td>애자일, 확장가능성, 수정가능성</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>Oracle, Mysql, PostgreSQL</td>
      <td>MongoDB, DynamoDB 등</td>
    </tr>
    <tr>
      <td>Schema</td>
      <td>엄격한 데이터 구조</td>
      <td>유연한 데이터 구조</td>
    </tr>
    <tr>
      <td>장점</td>
      <td> - 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장<br>
           - 데이터 중복 없이 한번만 저장(무결성)
      </td>
      <td> - 스키마가 없기 때문에 유연하고 자유로운 데이터<br>
           - 언제든 저장된 데이터를 조정하고 새로운 필드 추가할 수 있다.(자유로움)<br>
           - 데이터 분산이 용이하며 성능 향상을 위한 Scale-up뿐만이 아닌 Scale-out또한 가능
      </td>
    </tr>
    <tr>
        <td>단점</td>
        <td> - 테이블 간 관계를 맺고 있어 시스템이 커질 경우 Join문이 많은 복잡한 쿼리가 만들어 질 수 있다.<br>
             - 성능 향상을 위해서는 Scale-up을 지원.<br>
             - 스키마로 인해 데이터가 유연하지 못하다. (스키마가 변경 될 경우 번거롭고 어렵다.)
        </td>
        <td> - 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경 될 경우 수정을 모든 컬렉션에서 수행해야 한다.<br>
             - 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정하기가 어려울 수 있다.
        </td>
    </tr>
</table>

---
2. 트랜잭션(transaction)이란 무엇인가요?
<pre>
데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미 
</pre>

#### 특징
1. 트랜잭션은 데이터 베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다.
2. 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다.
3. 하나의 트랜직션은 Commit되거나 Rollback된다.

#### Atomicity(원자성)
1. 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
2. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

#### Consistency(일관성)
1. 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
2. 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

#### Isolation(독립성,격리성)
1. 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
2. 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

#### Durablility(영속성,지속성)
1. 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

---
3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.
### 조인이란
- 한 데이터베이스 내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것이다.
- 따라서 조인은 테이블로서 저장되거나, 그 자체로 이용할 수 있는 결과 셋을 만들어 낸다.

### 조인의 필요성
- 관계형 데이터베이스의 구조적 특징으로 정규화를 수행하면 의미 있는 데이터의 집합으로 테이블이 구성되고 각 테이블끼리는 관계(Relationship)을 갖게 된다.
- 이와 같은 특징으로 관계형 데이터베이스는 저장 공간의 효율성과 확장성이 향상되게 된다.
- 다른 한편으로는 서로 관계 있는 데이터가 여러 테이블로 나뉘어 저장되므로 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요하다.

---
4. MySQL에서 인덱스(index)란 무엇인가요?
### 인덱스
데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조
테이블의 특정 컬럼(Column)에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.
컬럼의 값과 물리적 주소를(key, value)의 한쌍으로 저장한다.

인덱스는 책에서의 __목차__ 혹은 __색인__ 이라고 생각하면 된다. 책에서 원하는 내용을 찾을 때 목차나 색인을 이용하면 훨씬 빠르게 찾을 수 있는데, 마찬가지로 테이블에서 원하는 데이터를 찾기 위해 인덱스를 이용하면 빠르게 찾을 수 있다. 
그러므로 데이터 = 책의 내용, 인덱스 = 책의 목차, 물리적 주소 = 책의 페이지 번호라고 생각할 수 있다. 

#### 장점
인덱스의 장점으로는 테이블을 검색하는 속도와 성능이 향상된다. 또 그에따라 시스템의 전반적인 부하를 줄일 수 있다.

핵심은 인덱스에 의해 데이터들이 정렬된 형태를 갖는다는 것이다. 기존엔 Where문으로 특정 조건의 데이터를 찾기 위해서 테이블의 전체를 조건과 비교해야 하는 '풀 테이블 스캔(Full Table Scan)' 작업이 필요했는데, 인덱스를 이용하면 데이터들이 정렬되어 있기 때문에 조건에 맞는 데이터를 빠르게 찾을 수 있다. 

또 ORDER BY 문이나 MIN/MAX 같은 경우도 이미 정렬이 되어 있기 때문에 빠르게 수행할 수 있다. 

#### 단점
인덱스가 항상 정렬된 상태로 유지되어 오는 장점도 있지만, 그에 따른 여러 단점도 존재한다. 
1. 인덱스를 관리하기 위한 추가 작업이 필요
2. 추가 저장 공간 필요
3. 잘못 사용하는 경우 오히려 검색 성능 저하

인덱스를 항상 정렬된 상태로 유지해야 하기 때문에 인덱스가 적용된 컬럼에 삽입(INSERT), 삭제(DELETE), 수정(UPDATE) 작업을 수행하면 다음과 같은 추가 작업이 필요하다. 

- INSERT : 새로운 데이터에 대한 인덱스를 추가
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
- UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가
